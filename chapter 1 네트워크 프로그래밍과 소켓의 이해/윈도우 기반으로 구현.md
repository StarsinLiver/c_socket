## 윈도우 기반으로 구현하기

상당수의 프로젝트에서는 서버를 리눅스 계열의 운영체제 기반으로 개발한다. 그러나 반대로 클라이언트 프로그램의 경우에는 윈도우 기반의 개발이 절대적이다. 뿐만아니라, 리눅스 기반으로 구현되어 있는 서버프로그램을 윈도우 기반으로 변경하거나, 윈도우 기반으로 구현되어있는 서버 프로그램을 리눅스 기반으로 변경해야 하는 상황도 종종 발생한다. 때문에 소켓 프로그래밍에 대해서는 리눅스 , 윈도우 개발이 가능하도록 공부하는 것이 좋다.

### 윈도우 소켓을 위한 헤더와 라이브러리의 설정
윈속(윈도우 소켓)을 기반으로 프로그램을 개발하기 위해서는 기본적으로 다음 두 가지를 진행해야 한다.

1. 헤더파일  winsock2.h 를 포함한다.
2. ws2_32.lib 라이브러리를 링크시켜야 한다.

### 윈속(windsock)의 초기화
윈속 프로그래밍을 할 때에는 반드시 WSAStartup 함수를 호출해서, 프로그램에서 요구하는 윈도우 소켓의 버전을 알리고, 해당 버전을 지원하는 라이브러리의 초기화 작업을 진행해야 한다.

```c
#include <windsock2.h>

int WSAStartup(WORD wVersionRequested , LPWSADATA lpWSAData); // 성공 시 0 , 실패 시 0 이 아닌 에러 코드 반환

// wVersionRequested : 프로그래머가 사용할 윈속의 버전정보 전달
// lpWSAData : WSADATA라는 구조체 변수의 주소 값 전달
```

위의 두 매개변수에 대해서는 별도의 자세한 설명이 필요하다. 먼저 첫번째 매개변수에 대해서는 윈도우 소켓에는 몇몇 버전이 존재한다,. 따라서 사용할 소켓의 버전정보를 WORD 형으로 구성해서 (참고로 WORD는 typedef 서넝ㄴ을 통해서 unsigned  short 로 정의되어 있다.) 위 함수의 첫번째 매개변수 wVersionRequested로 전달해야 한다. 만약에 사용할 소켓의 버전이 1.2 라면 , 1이 주 버전이고, 2가 부버전이므로 0x0201을 인자로 전달해야 한다.

이렇듯 상위 8비트에는 부 버전 정보를 , 하위 8비트에는 주 버전 정보를 표시해서 인자로 전달하게 되는데 우리는 버전 2.2 를 기반으로 프로그래밍을 하기 때문에 0x0202를 인자로 전달하면 된다. 그런데 바이트 단위로 쪼개서 버전정보를 설정하는 것이 조금 번거롭다면 매크로 함수인 MAKEWORD 를 제공하고 있다. 이 함수를 사용하면 다음과 같이 간단히 WORD 형 버전정볼르 구성할 수 있다.

```c
MAKEWORD(1 , 2); // 주 버전 1 , 부 버전 2 0x0201 를 반환
MAKEWORD(2 , 2); // 주 버전 2 , 부 버전 2 0x0202 를 반환
```

이어서 두 번째 매개변수 lpWSAData 이다. 이 매개변수에는 WSADATA 구조체 변수의 주소값을 인자로 전달해야 한다. (LPWASDATA는 WSADATA의 포인터 형이다.) 그러면 함수호출이 완료되고 난 다음에 해당 변수에는 초기화된 라이브러리의 정보가 채워진다. 특별히 큰 의미를 지니지는 않지만, 함수 호출을 위해서는 반드시 WSADATA 구조체 변수의 주소값을 전달해야한다.

이번에는 초기화된 라이브러리의 해제 방법에 대해서 설명하겠다. 이를 위해 함수를 하나 소개하겠다. 이 함수가 윈속 라이브러리의 해제에 사용되는 함수이다.
```c
#include <windock2.h>

int WSACleanup(void); // 성공 : 0 , 실패 : SCOKET_ERROR를 반환
```

밑의 예제는 거의 공식이다.
```c
#include <winsock2.h>
int main(void) {
  WSADATA wsaData;

  ...

  if(WSAStartup(MAKEWORD(2,2) , &wsaData) != 0) {
    // 에러 핸들링
  }

  if(WSACleanup() == SOCKET_ERROR) {
    //  에러 핸들링
  } 
    
  return 0;
}
```


<br/>

