## TCP  소켓에 존재하는 입출력 버퍼
TCP 소켓의 데이터 송수신에는 경계가 없음을 수 차례 설명하였다. 따라서 서버가 한번의 write 함수 호출을 통해서 40 바이트를 전송해도 클라이언트는 네 번의 read 함수호출을 통해서 10바이트씩 데이터를 수신하는 것이 가능함을 우리는 잘 알고 있을 것이다. 그런데 이러한 현상에 의문을 가질 것이다.
서버는 데이터를 한번에 40바이트를 전송했는데, 클라이언트가 이를 여유있게 조금씩 수신하니 말이다. 클라이언트가 10 바이트만 먼저 수신했다면 서버가 보낸 나머지 30바이트는 어디서 대기하고 있는것일까?

사실 write 함수가 호출되는 순간이 데이터가 전송되는 순간이 아니고, read 함수가 호출되는 순간이 데이터가 수신되는 순간이 아니다. 정확히 말하면 write 함수가 호출되는 순간 데이터는 출력버퍼로 이동을 하고, read 함수가 호출되는 순간 입력 버퍼에 저장된 데이터를 읽어 들이게 된다.

![alt text](https://mblogthumb-phinf.pstatic.net/MjAxOTA0MDlfMTM1/MDAxNTU0NzkzNDkzNjU2.QaHatLalDnTLPIWExpB_gPAERm0fLcTcZXN-WT8Hpmsg.DwcrC0m8RlM_Brf8iVkGKtraeVSctufxZJFATgWqvfwg.PNG.ihp0001/image.png?type=w800)

위 그림에서 보이듯이 write 함수가 호출되면 출력 버퍼라는 곳에 데이터가 전달되어서 상황에 맞게 적절히 데이터를 상대방 입력버퍼로 전송한다. 그러면 상대방은 read 함수 호출을 통해서 입력버퍼에 저장된 데이터를 읽게 되는 것이다. 이러한 입출력 버퍼의 특성을 몇가지 정리해보자

1. 입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재한다.
2. 입출력 버퍼는 소켓생성시 자동으로 생성된다.
3. 소켓을 닫아도 출력버퍼에 남아있는 데이터는 계속해서 전송이 이뤄진다.
4. 소켓을 닫으면 입력버퍼에 남아있는 데이터는 소멸되어버린다.

그렇다면 다음 같이 상황이 발생하면 어떻겠는가?

"클라이언트의 입력버퍼 크기가 50 바이트인데, 서버에서 100바이트를 전송하였다"

이는 문제가 아닐 수 없다. 입력버퍼의 크기가 50바이트인데, 100바이트가 전송되니 말이다. 물론 다음과 같은 해결책을 제시할 수 있다.

"입력버퍼가 채워지기 전에 잽싸게 read 함수를 호출해서 데이터를 읽어 들이는 겁니다. 그럼 읽어 들인 만큼 버퍼가 비워지니 문제가 되지 않겠죠!"

웃자고 한 얘기다.

"입력 버퍼의 크기를 초과하는 분량의 데이터 전송은 발생하지 않습니다!"

즉, 우리가 고민하는 상황은 절대 일어나지 않는다. 왜냐하면 TCP 가 데이터의 흐름까지 컨트롤하기 때문이다. TCP 에는 '슬라이딩 윈도우 (Sliding window)' 라는 프로토콜이 존재한다. 이 프로토콜의 역할을 대화로 표현하면 다음과 같다.

```
소켓 A : 야 50바이트까지는 보내도 괜찮아!
소켓 B : OK!

소켓 A : 내가 20바이트 비웠으니깐 70바이트까지 괜찮아!
소켓 B : OK!
```

이렇듯 서로 대화를 주고받으면서 데이터를 송수신하기 때문에 버퍼가 차고 넘쳐서 데이터가 소멸되는 일이 tcp 에서는 발생하지 않는다.

## TCP 의 내부동작 원리1 : 상대 소켓과의 연결
TCP 소켓의 생성에서 소멸의 과정까지 거치게 되는 일을 크게 나누면 다음 세가지로 구분할 수 있다.

1. 상대 소켓과의 연결
2. 상대 소켓과의 데이터 송수신
3. 생대 소켓과의 연결종료

그럼 먼저 상대 소켓과의 연결이 어떻게 이뤄지는지 설명하겠다. 연결설정 과정에서 두 소켓이 주고받는 대화의 내용을 간단히 정리하면 다음과 같다.

```
소켓 A : HI! 소켓 B, 내가 전달할 데이터가 있으니 우리 연결 좀 하자.
소켓 B : 알았어! 지금 나도 준비가 되었으니 언제든지 좋아
소켓 A : 좋아 고마워
```

실제로 TCP 소켓은 연결설정 과정에서 총 3버느이 대화를 주고 받는다. 그래서 이를 가리켜 Thread-way handshaking 이라 한다. 즉, 세번 악수 했다는 의미이다. 그럼 연결설정 과정에서 주고받는 메시지의 형태를 다음 그림을 통해서 보자

![alt text](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSMmycvwxsj_7DA_-Agu4NhxyBYpAI0bfJP4w&s)

소켓은 전 이중 (Full-duplex) 방식으로 동작하므로 양방향으로 데이터를 주고 받을 수 있다. 따라서 데이터 송수신에 앞서 준비 과정이 필요하다. 먼저 연결요청을 하는 호스트 A 가 호스트 B 에게 다음 메시지를 전하고 있다.

```
[SYN] SEQ : 1000 ACK : -  
```

이는 SEQ 1000, ACK 는 비었음을 뜻하는데, 여기서 SEQ 1000이 의미하는 바는 다음과 같다

"내가 지금 보내는 이 패킷에 1000이라는 번호를 부여하니, 잘 받았다면 다음에는 1001번 패킷을 전달하라고 내게 말해달라!"

이는 처음 연결 요청에 사용되는 메시지이기때문에 이 메시지를 가리켜 SYN 이라고 한다. 그리고 SYN 은 Synchronization 의 줄임말로써 데이터 송수신에 앞서 전송되는 '동기화 메시지'라는 의미를 담고 있다. 이어서 호스트 B 가 호스트 A 에게 다음메시지를 전달한다.

```
[SYN + ACK] SEQ : 2000 ACK : 1001
```
이는 SEQ 2000 , ACK 가 1001 임을 뜻하는데 여기서 SEQ 2000 이 의미하는 바는 다음과 같다.

"내가 지금 보내는 이 패킷에 2000이라는 번호를 부여하니, 잘 받았다면 다음에는 2001 번 패킷을 전달하라고 내게 말해달라!"

그리고 ACK 1001 이 의미하는 바는 다음과 같다

"좀 전에 전송한 SEQ 가 1000인 패킷은 잘 받았으니, 다음번에는 SEQ가 1001인 패킷을 전송하기 바란다!"

즉, 처음 호스트 A가 전송한 패킷에 대한 '응답 메시지 (ACK 1001)' 과 함께 호스트 B의 데이터 전송을 위한 '동기화 메시지(SEQ 2000)'를 함께 묶어서 보내고 있다. 그래서 이러한 유형의 메시지를 가리켜 SYN + ACK 라 한다.

이렇듯 데이터의 송수신에 앞서 송수신에 사용되는 패킷에 번호를 부여하고 이 번호정보를 상대방에게 알리는 이유는 데이터의 손실을 막기 위함이다. 이렇게 패킷에 번호를 부여해서 확인하는 절차를 거치기 때문에 손실된 데이터의 확인 및 재전송이 가능한 것이고 , 때문에 TCP는 손실 없는 데이터의 전송을 보장하는 것이다. 그럼 마지막으로 호스트 A가 호스트 B에게 전송한 메시지를 살펴보자

```
[ACK] SEQ : 1001 , ACK : 2001
```
이미 앞서 한차례씩 송수신한 패킷에서 보였듯이 TCP 의 연결과정에서 패킷을 보낼 때에는 항상 번호를 부여한다 그래서 SEQ 1001 이 부여되었다. 앞서 보낸 패킷의 SEQ 가 1000 이었으니 이번에는 이보다 1 증가한 1001이 부여된 것이다. 그리고 이 패킷은 다음의 메시지 전달을 목적으로 전송되었다

"좀 전에 전송한 SEQ가 2000인 패킷은 잘 받았으니, 다음번에는 SEQ 가 2001 인 패킷을 전송하기 바란다!"

때문에 ACK 2001 이 추가된 형태의 ACK 메시지가 전송되었다. 이로써 호스트 A, 호스트 B 상호간의 데이터 송수신을 위한 준비가 모두 되었음을 서로 인식하게 되었다.

## TCP 의 내부 동작원리2 : 상대 소켓과의 데이터 송수신
데이터 송수신의 기본방식은 다음과 같다.

![alt text](https://postfiles.pstatic.net/MjAxOTA0MDlfNjcg/MDAxNTU0Nzk3MTExMzUy.vKKYhJH7j6xY_UbAU_Jm0X07wpPbWjuq9BphCNm0NFEg.F_FhvEYKJFUr7kLJzTp8AEbWp3GTyJ382AjfOCluPjwg.PNG.ihp0001/image.png?type=w773)


ACK 메시지를 다음의 공식을 기준으로 전송한다.

```
ACK 번호 == SEQ 번호 + 전송된 바이트 크기 + 1
```

이는 패킷에 담긴 100바이트가 전부 전송되었는지, 아니면 그 중 일부가 손실되고 80바이트만 전송되었는지를 확인하기 위해 위의 공식을 사용한다. 마지막에 1을 더하는 이유는 Three-way handshaking 에서도 보였듯이, 다음 번에 전달될 SEQ의 번호를 알리기 위함이다. 그럼 중간에 소멸된다면 어떻게 될까?


![alt text](https://mblogthumb-phinf.pstatic.net/MjAxOTA0MDlfOTgg/MDAxNTU0Nzk3NzMyMzMy.G_yTWktcPYX00JzmepGzJdhSLtFtOgBhRGQ14twokecg.MqAnUteY6j2h8wBBcjSLDWa8ltYKvCzBjSLYspNscYcg.PNG.ihp0001/image.png?type=w800)

재전송을 진행하는 것을 알 수 있다. 이렇듯 데이터의 손실에 대한 재전송을 위해서 , TCP 소켓은 ACK 응답을 요구하는 패킷 전송시에 타이머를 동작시킨다. 그리고 해당 타이머가 Time-out! 되었을때 패킷을 재전송한다.

## TCP의 내부 동작원리 3: 상대 소켓과의 연결종료
TCP 소켓은 연결종료도 매우 우아하게 진행하는데.

```
소켓 A : 전 연결을 끊고자 합니다.
소켓 B : 아! 그러세요? 잠시만 기다리세요.

소켓 B : 네 저도 준비가 끝났습니다. 그럼 연결을 끊으시지요
소켓 A : 네! 그동안 즐거웠습니다.
```

먼제 소켓 A가 종료 메시지를 소켓 B에게 전달하고, 소켓 B는 해당 메시지의 수신을 소켓 A에게 알린다. 그리고 이어서 소켓 B가 종료 메시지를 소켓A에게 전달하고, 소켓A는 해당 메시지의 수신을 소켓 B에게 알리며 종료의 과정을 마치게 된다.

![alt text](https://postfiles.pstatic.net/MjAxOTA0MDlfMjYy/MDAxNTU0Nzk4MDkzMDUx.u-8phhmTUtk9SsRxCpaWxyuPvJ2GsZ3YA0lE3ojqpugg.a2uY4zZpoq7sKRw5aXw2zHTArUv9JTuq7ULKkTRN0FYg.PNG.ihp0001/image.png?type=w773)

위 그림에서 패킷안에 삽입되어 있는 FIN 은 종료를 알리는 메시지를 뜻한다. 즉, 상호간에 FIN 메시지를 한번씩 주고 받고서 연결이 종료되는데, 이 과정이 네 단계에 걸쳐서 진행되기 때문에 이를 가리켜 Four-way handshking 이라고 부른다.지금까지 TCP 프로토콜의 기본이 되는 'TCP 흐름제어(Flow Control)' 를 조금 설명하였다.