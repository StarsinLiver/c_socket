## 네트워크 바이트 순서와 인터넷 주소 변환
CPU 에 따라서 4바이트 정수 1을 메모리공간에 저장하는 방식이 달라질 수 있음을 알고 있는가? 4바이트 정수 1을 2진수로 표현하면 다음과 같다.

00000000 00000000 00000000 00000001

이 순서 그대로 메모리에 저장하는 CPU 가 있는 반면 다음과 같이 거꾸로 저장하는 CPU도 있다.

00000001 00000000 00000000 00000000

때문에 이러한 부분을 고려하지 않고서 데이터를 송수신하면 문제가 발생할 수 있다. 저장순서가 다르다는 것은 전송되어온 데이터의 해석 순서가 다름을 뜻하기 때문이다.

## 바이트 순서 (Order) 와 네트워크 바이트 순서
CPU 가 데이터를 메모리에 저장하는 방식은 다음과 같이 두가지가 있다. 참고로 CPU 가 데이터를 메모리에 저장하는 방식이 두 가지로 나뉜다는 것은 CPU 가 데이터를 해석하는 방식도 두 가지로 나뉜다는 뜻이다.

1. 빅 엔디안 (Big Endian) : 상위 바이트의 값을 작은 번지수에 저장하는 방식
2. 리틀 엔디안 (Little Endian) : 상위 바이트의 값을 큰 번지수에 저장하는 방식

이 둘은 말로만 이해하기에는 부담스럽다. 그래서 예를 하나 들어보자 0x20 번지를 시작으로 4바이트 int 형 정수 0x12345678을 저장한다고 가정해보자. 빅 엔디안 방식의 CPU는 다음의 형태로 메모리에 저장한다.

```
정수 0x12345678

0x20 번지 : 0x12
0x21 번지 : 0x34
0x22 번지 : 0x56
0x23 번지 : 0x78
```

정수 0x12345678중에서 0x12 가 최상위 바이트, 0x78 이 최하위 바이트이다 따라서 빅 엔디안 방식에서는 최상위 바이트인 0x12 부터 저장된다. (최상위 바이트인 0x12가 작은 번지수에 저장된다.) 반면 리틀 엔디안 방식은 위의 그림과 반대의 순서로 저장된다


```
정수 0x12345678

0x20 번지 : 0x78
0x21 번지 : 0x56
0x22 번지 : 0x34
0x23 번지 : 0x12
```

위와 같이 최하위 바이트인 0x78이 먼저 저장되고 있다. 이렇듯 데이터 저장방식은 CPU 마다 다르다 그래서 CPU의 데이터 저장방식을 의미하는 '호스트 바이트 순서 (Host Byte Order)'는 CPU에 따라서 차이가 난다. 우리가 주로 사용하는 인텔 CPU 는 리틀 엔디안 방식으로 데이터를 저장한다.

따라서 빅 엔디안 시스템에서 전송한 데이터를 리틀 엔디안 시스템에서 받는다면 빅 엔디안 시스템에서 0x12 , 0x34 의 조합으로 만들어지는 값은 리틀 엔디안 시스템에서 0x34 , 0x12 의 조합으로 만들어지는 값과 같다. 즉 저장되는 순서가 바뀌어야 동일한 값으로 인식된다. 그런데 바이트 순서에 대한 문제를 고려하지 않고 0x12 , 0x34 순으로 데이터를 전송한다면 결국 리틀 엔디안 시스템은 전송되는 순서대로 데이터를 저장한다. 때문에 전송된 값은 리틀 엔디안잆장에서 0x1234 가 아닌 0x3412 가 되어버린다. 바로 이러한 문제점 때문에 네트워크를 통해서 데이터를 전송할 때에는 통인된 기준으로 데이터를 전송하기로 약속하였으며 이 약속을 가리켜 '네트워크 바이트 순서 (Network Byte Order)' 라 한다. 네트워크 바이트 순서의 약속은 매우 간단하다

"빅 엔디안 방식으로 통일합시다!!!"

즉, 네트워크 상으로 데이터를 전송할 때에는 데이터의 배열을 빅 엔디안 기준으로 변경해서 송수신하기로 약속한 것이다. 때문에 모든 컴퓨터는 수신된 데이터가 네트워크 바이트 순서로 정렬되어 있음을 인식해야하며 , 리틀 엔디안 시스템에서는 데이터를 전송하기에 앞서 빅 엔디안의 정렬방식으로 데이터를 재정렬해야 한다.


## 바이트 순서의 변환 (Endian Conversions)
이제 sockaddr_in 구조체 변수에 값을 채우기 앞서 네트워크 바이트 순서로 변환해서 저장해야 하는 이유를 알았을 것이다. 그럼 이번에는 바이트 순서의 변환을 돕는 함수를 살펴보자

|함수|
|:--:|
|unsigned short htnos(unsigned short)|
|unsigned short ntohs(unsigned short)|
|unsigned long  htonl(unsigned short)|
|unsigned long  nthol(unsigned short)|

혹시 함수의 이름만 보고도 그 기능을 파악할 수 있겠는가? 다음 사실만 알면 위 함수의 기능을 쉽게 파악할 수 있다.

1. htons 에서는 h 는 호스트 (host) 바이트 순서를 의미한다.
2. htons 에서의 n은 네트워크 (network) 바이트 순서를 의미한다.
3. htons 에서의 s 는 short를 의미한다.
4. htonl 에서의 l 는 long을 의미한다.

따라서 htons 는 h(host) to n(network) , s(short) 의 조합이므로 다음과 같이 해석할 수 있다.

"short 형 데이터를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환해라!"

일반적으로 뒤에 s 가 붙는 함수는 s가 2바이트 short 를 의미하므로 PORT 번호의 변환에 사용되고 뒤에 l이 붙는 함수는 l 이 4바이트를 의미하므로 IP 주소의 변환에 사용된다. 그리고 혹 다음과 같이 생각할 수 있다.

"내 시스템은 빅 엔디안으로 동작하거든요! 그럼 전 sockaddr_in 구조체 변수에 값을 채울 때 네트워크 바이트 순서로 변환할 필요가 없나요?"

틀린말은 아니지만, 리틀 엔디안 , 빅 엔디안에 상관없이 동일하게 동작하는 코드를 작성할 필요가 있다. 따라서 빅 엔디안 시스템에서도 호스트 바이트 순서를 네트워크 바이트 순서로 변환하는 것이 좋다.
물론 이 경우에는 호스트 바이트 순서와 네트워크 바이트 순서가 동일하기 때문에 아무일도 일어나지 않는다. 그럼 간단한 예제를 보고 위의 함수를 호출해보자

```c

#include <arpa/inet.h>
#include <stdio.h>

int main() {
  unsigned short host_port = 0x1234;
  unsigned short net_port;
  unsigned long host_addr = 0x12345678;
  unsigned long net_addr;

  net_port = htons(host_port);
  net_addr = htonl(host_addr);

  printf("Host ordered port : %#x \n", host_port);
  printf("Network ordered port : %#x \n", net_port);

  printf("Host ordered address : %#lx \n", host_addr);
  printf("Network ordered address :%#lx \n", net_addr);
  return 0;
}
```

```c
Host ordered port : 0x1234
Network ordered port : 0x3412
Host ordered address : 0x12345678
Network ordered address :0x78563412
```

위의 실행결과는 리틀엔디안 기준으로 정렬하는 CPU 에서의 실행결과이다. 만약 빅 엔디안 기준으로 정렬하는 CPU 상에서 실행했다면 변환 이후에도 값은 달라지지 않는다. 참고로 우리는 대부분이 인텔 또는 AMD 계엘의 CPU 를 사용하고 있기에 위의 결과를 얻을 수 있다.

