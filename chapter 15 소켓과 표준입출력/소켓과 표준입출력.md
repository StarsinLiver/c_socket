## 표준 입출력 함수의 장점

이번 챕터에서는 표준 입출력 함수를 이용한 데이터 송수신 방법에 대해 소개하겠다.

## 표준 입출력 함수의 두가지 장점

표준 입출력 함수를 데이터 송수신에 사용하는 것은 그리 어려운 일이 아니다. 하지만 무조건 사용방법만 익히는 것은 의미가 없다. 최소한 어떠한 장점이 있는지 이해해야 의미가 있다.
다음은 표준 입출력 함수가 지니는 장점 두 가지이다.

```
1. 표준 입출력 함수는 이식성(Portability)이 좋다.
2. 표준 입출력함수는 버퍼링을 통한 성능의 향상에 도움이 된다.
```

이식성에 대해서는 많은 이야기가 필요 없을 것이다. 어찌되었든 입출력 함수뿐만 아니라, 모든 표준 함수들은 이식성이 좋다. 모든 운영체제(컴파일러)가 지원하도록 ANSI C에서 표준으로 정의했기 때문이다. 물론 이는 네트워크 프로그래밍에만 해당하는 이야기가 아니다. 프로그래밍의 모든 영역에 해당하는 이야기이다.

그럼 이어서 표준 입출력 함수의 두 번째 장점에 대해서 이야기해 보자 표준 입출력 함수를 사용할 경우 추가적으로 입출력 버퍼를 제공받게된다. 그런데 이렇게 이야기하면 다소 혼란스러울 수 있다. 왜냐하면 이전에 언급하길 소켓을 생성하면 기본적으로 운영체제에 의해서 입출력 버퍼가 생성된다고 했기 때문이다.

이들의 버퍼의 관계를 정리해보자. 소켓을 생성하면 운영체제는 입출력을 위한 버퍼를 마련한다. 그리고 이 버퍼는 TCP 프로토콜을 진행하는 데 매우 중요한 역할을 한다. 그런데 이와는 별도로 표준 입출력 함수를 사용하게 되면, 이에 더불어 추가로 또 하나의 버퍼를 제공받는다.

위 그림에서 보이듯이 표준 입출력 함수를 사용해서 데이터를 전송할 경우, 거쳐야하는 버퍼의 수는 두 개가 된다. 예를 들어서 fputs 함수를 통해서 "Hello"라는 문자열을 전송할 경우, 일단 표준 입출력 함수의 버퍼에 데이터가 전달된다. 그리고 이어서 소켓의 출력버퍼로 이동하고, 마지막으로 상대방에게 문자열이 전송된다.

이제 제공되는 두 버퍼의 위치관계를 파악했으니 각각의 용도에 대해서 이야기해 보자. 버퍼는 기본적으로 성능의 향상을 목적으로 한다. 하지만 소켓과 관련해서 제공되는 버퍼는 TCP의 구현을 위한 목적이 더 강하다. 예를 들어서 TCP의 경우 데이터가 분실되면 재 전송을 진행한다. 그런데 재전송이 이뤄진다는 것은 데이터를 어딘가에 저장해 놓았다는 의미가 된다. 어디에 저장하겠는가? 소켓의 출력버퍼가 아니겠는가? 반면 표준 입출력 함수 사용시 제공되는 버퍼는 오로지 성능 향상만을 목적으로 제공이 된다.

![alt text](/image/25.png)

"버퍼링을 하면 성능이 많이 좋아지나요?"

사실 버퍼링이 모든 상황에서 우월한 성능을 보이는 것은 아니다. 그러나 전송해야할 데이터의 양이 많으면 많을수록 버퍼링의 유무에 따른 성능의 차이는 너무나도 크다. 일단 다음 두 가지 관점에서 성능으 우월함을 말할 수 있다.

```
1. 전송하는 데이터의 양
2. 출력버퍼로의 데이터 이동 횟수
```

1바이트짜리 데이터를 총 열번에 걸쳐서(열 개의 패킷에) 보내는 경우와 이를 버퍼링해서 10바이트로 묶어서 한번에 전송하는 상황을 예로 비교해보겠다. 데이터의 전송을 위해서 구성된 패킷에는 헤더정보라는 것이 추가된다. 이는 데이터의 크기에 상관없이 일정한 크기구조를 갖는데, 이를 패킷당 40바이트만 잡아도 다음과 같이 전송해야 할 데이터의 양에는 큰 차이가 난다.

```
1바이트 * 10회 : 40 * 10 = 400 바이트
10바이트 * 1회 : 40 * 1 = 40바이트
```

그리고 데이터의 전송을 위해 소켓의 출력버퍼로 데이터를 이동시키는데도 시간이 제법 많이 소모가 된다. 그런데 이 역시 이동 횟수와 관련이 있다. 1바이트를 10회 이동하는데 걸리는 시간이 이를 묶어서 10바이트를 한번에 이동하는 것보다 열배 가까운 시간이 더 소모된다.

## 표준 입출력 함수와 시스템 함수의 성능비교

버퍼링이 성능에 도움이 되는 이유에 대해 실제로 눈으로 확인하지 않으면 막연하게만 느껴진다. 그래서 표준 입출력 함수를 이용한 파일복사 프로그램과 시스템 함수를 이용한 파일복사 프로그램을 이용해서 실제 버퍼링이 갖는 위력이 어느정도인지 확인해 보자

다음예제는 시스템 함수를 이용한 파일복사프로그램이다.

```c
// syscpy.c
#include <stdio.h>
#include <fcntl.h>
#define BUF_SIZE 3 // 배열의 길이를 최소한으로 구성

int main(int argc, char const *argv[])
{
  int fd1 , fd2;
  int len;
  char buf[BUF_SIZE];

  fd1 = open("news.txt" , O_RDONLY);
  fd2 = open("cpy.txt" , O_WRONLY | O_CREAT | O_TRUNC);

  while((len = read(fd1 , buf , sizeof(buf))) > 0) {
    write(fd2 , buf , len);
  }

  close(fd1);
  close(fd2);
  return 0;
}
```

복사대상은 크기가 300MByte 이상인 파일로 하자! 그래야 성능의 차이를 확실히 느낄 수 있다. 다음은 표준 입출력 함수를 이용해서 파일을 복사한다.

```c
#include <stdio.h>
#define BUF_SIZE 3

int main(int argc, char const *argv[])
{
  FILE * fp1 , * fp2;
  char buf[BUF_SIZE];

  fp1 = fopen("news.txt" , "r");
  fp2 = fopen("cpy.txt" , "w");

  while(fgets(buf , BUF_SIZE , fp1) != NULL)
    fputs(buf , fp2);

  close(fp1);
  close(fp2);
  return 0;
}
```

이 예제에서는 기본적으로 버퍼링 기반의 복사가 이루어 진다. 단순한 파일 복사임에도 불구하고 이렇게 성능의 차이가 많이나는데 실제 네트워크 상에서 데이터를 송수신한다면 얼마나 큰 성능의 차이를 보이겠는가?

## 표준 입출력 함수 사용에 있어서 몇 가지 불편한 사항

여기서 이야기를 끝내면ㅡ 표준 입출력 함수가 마냥 좋게만 느겨진다. 하지만 이를 기반으로 하는 입출력에도 나름 단점이 있다. 이를 정리하면 다음과 같다.

```
1. 양방향 통신이 쉽지 않다.
2. 상황에 따라서 fflush 함수의 호출이 빈번히 등장할 수 있다.
3. 파일 디스크립터를 FILE 구조체의 포인터로 변환해야 한다.
```

파일을 열 때도 읽고 쓰기가 동시에 가능하려면 r+ , w+ , a+ 모드로 파일을 열어야한다. 그런데 이것이 전부가 아니다. 버퍼링 문제로 인해서 읽기에서 쓰기로 쓰기에서 읽기로 작업의 형태를 바꿀 때마다 fflush 함수를 호출해야 하는데, 이렇게 되면 표준 입출력 함수의 장점인 버퍼링 기반의 성능향상에도 영향을 미친다. 뿐만 아니라, 표준 입출력 함수의 사용을 위해서 FILE 구조체의 포인터 가 필요한데, 기본적으로 소켓은 생성시에 파일 디스크립터를 반환한다. 따라서 파일 디스크립터를 FILE 포인터로 변환하는 과정을 거쳐야 한다. 혹시 FILE 포인터의 파일디스크립터가 구분되지 않는다면, 앞서 제시한 두 예제를 통해서 확인 바란다.
