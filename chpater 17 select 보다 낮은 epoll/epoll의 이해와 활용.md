## epoll 의 이해와 활용

사실 select 는 오래 전에 개발된 멀티플렉싱 기법이다. 때문에 이를 이용하면 아무리 프로그램의 성능을 최적화 시킨다 해도, 허용할 수 있는 동시접속자의 수가 백을 넘기 힘들다. 이러한 select 방식은 웹 기반의 서버개발이 주를 이루는 오늘날의 개발 환경에서는 적절치 않다. 따라서 이에 대한 대안으로 리눅스 영역에서 주로 활용되는 epoll 에 대해 공부하고자 한다.

## select 기반의 IO 멀티플렉싱이 느린 이유

Chapter 12 에서 select 기반의 멀티플렉싱 서버를 구현해 본 경험이 있기 때문에 코드상에서의 불합리한 점을 쉽게 할 수 있는데, 가장 큰 두 가지는 다음과 같다.

```
1. select 함수호출 이후에 항상 등장하는, 모든 파일 디스크립터를 대상으로 하는 반복문
2. select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들
```

위의 두 가지는 Chapter 12 에서 소개한 예제 echo_selectserv.c 의 45 , 49 그리고 54 행에서 확인 가능하다. select 함수가 호출되고 나면, 상태변화가 발생한 파일 디스크립터만 따로 묶이는 것이 아니라, 관찰대상을 묶어서 인자로 전달한 fd_set형 변수의 변화를 통해서 상태변화가 발생한 파일 디스크립터를 구분하기 때문에 모든 파일 디스크립터를 대상으로 하는 반복문의 삽입은 어쩔 수 없는 일이다. 뿐만 아니라 관찰 대상을 묶어놓은 fd_set형 변수에 변화가 생기기 때문에 select 함수의 호출이전에 원본을 복사해두고 select 함수를 호출할 때마다 새롭게 관찰대상의 정보를 전달해야 한다.

그러면 우리는 어떤 것이 성능향상에 더 큰 걸림돌이라고 생각하는가? 그러니깐 select 함수호출 이후에 항상 등장하는 모든 파일 디스크립터 대상의 반복문이 더 큰 걸림돌이라고 생각하는가? 아니면 매번 전달해야 하는 관찰대상에 대한 정보들이 더 큰 걸림돌이라고 생각하는가?
코드만 놓고 보면 반복문이라 생각하기 쉽다. 그러나 반복문보다는 매번 전달해야 하는 관찰대상에 대한 정보들이 더 큰 걸림돌이다. 이는 다음을 뜻하는 것이기 때문이다.

"select 함수를 호출할 때마다 관찰대상에 대한 정보를 매번 운영체제에게 전달해야 한다."

응용 프로그램상에서 운영체제에게 데이터를 전달하는 것은 프로그램에 많은 부담이 따르는 일이다. 그리고 이는 코드의 개선을 통해서 덜 수 있는 유형의 부담이 아니기 때문에 성능에 치명적인 약점이 될 수 있다.

"그런데 왜 관찰대상에 대한 정보를 왜 운영체제에게 전달해야 하는가?"

함수 중에는 운영체제의 도움 없이 기능을 완성하는 함수가 있고, 운영체제의 도움이 절대적으로 필요한 함수가 있다. 예를 들어서 사칙연산과 관련된 함수를 우리가 정의했다고 가정해보자. 그렇다면 운영체제의 도움을 필요치 않는다. 그러나 select 함수는 파일 디스크립터 ,정확히 말하면 소켓의 변화를 관찰하는 함수이다. 그런데 소켓은 운영체제에 의해 관리되는 대상이 아닌가? 때문에 select 하뭇는 절대적으로 운영체제에 의해 기능이 완성되는 함수이다. 따라서 이러한 select 함수의 단점은 다음과 같은 방식으로 해결해야 한다.

"운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고서, 관찰대상의 범위 또는 내용에 변경이 있을때 변경 사항만 알려주도록 하자."

이렇게 되면 select 함수를 호출할 때마다 관찰대상에 대한 정보를 매번 운영체제에게 전달할 필요가 없다. 단, 이는 운영체제가 이러한 방식에 동의할 경우에나 가능한 일이다. (이러한 방식을 지원할 경우에나 가능한 일이다.) 때문에 운영체제 별로 지원여부도 다르고 지원방식에도 차이가 있다. 참고로 리눅스에서 지원하는 방식을 가리켜 epoll 이라 하고 윈도우에서는 IOCP 라한다.

## select 이거 필요 없는것인가? 아니다! 장점이 있다!

하지만 select 함수도 잘 알고 있어야 한다. 이번 챕터에서 설명하는 epoll 방식은 리눅스에서만 지원되는 방식이다. 이렇듯 개선된 IO 멀티플렉싱 모델은 운영체제 별로 호환되지 않느다.
반면 select 함수는 대부분의 운영체제에서 지원을 한다. 따라서 다음 두가지 유형의 조건이 만족 또는 요구되는 상황이라면 리눅스에서 운영할 서버라 할지라도 굳이 epoll 을 고집할 필요가 없다.

```
1. 서버의 접속자 수가 많지 않다.
2. 다양한 운영체제에서 운영이 가능해야 한다.
```

이렇듯 모든 상황에서 절대 우위를 점하는 구현모델은 존재하지 않는다. 그러니 우리는 하나닁 모델을 고집하기 보다는 모델 별 장단점을 정확히 이해하고 적절히 적용할 수 있어야 한다.

## epoll 의 구현에 필요한 함수와 구조체

select 함수의 단점을 극복한 epoll 에는 다음의 장점이 있다. 이는 앞서말한 select함수의 단점에 상반된 특징이기도 한다.

```
1. 상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
2. select 함수에 대응하는 epoll_wait 함수호출시, 관찰대상의 정보를 매번 전달할 필요가 없다.
```

자! 그럼 epoll 기반의 서버 구현에 필요한 세 가지 함수를 소개할 것이다.

```
1. epoll_create   : epoll 파일 디스크립터 저장소 생성
2. epoll_ctl      : 저장소에 파일 디스크립터 등록 및 삭제
3. epoll_wait     : select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.
```

select 방식에서는 관찰대상인 파일 디스크립터의 저장을 위해서 fd_set 형 변수를 직접 선언했었다. 하지만 epoll 방식에서는 관찰대상인 파일 디스크립터의 저장을 운영체제가 담당한다. 때문에 파일 디스크립터의 저장을 위한 저장소의 생성을 운영체제에게 요청해야 하는데 이 때 사용되는 함수가 epoll_create 이다.

그리고 관찰대상인 파일 디스크립터의 추가, 삭제를 위해서 select 방식에서는 FD_SET , FD_CLR 함수를 사용하지만, epoll 방식에서는 epoll_ctl 함수를 통해서 운영체제에게 요청하는 방식으로 이뤄진다.

마지막으로 select 방식에서는 파일 디스크립터의 변화를 대기하기 위해서 select 함수를 호출하는 반면, epoll 에서는 epoll_wait 함수를 호출한다. 그런데 이것이 끝이 아니다. select 방식에서는 select 함수호출 시 전달한 fd_set 형 변수의 변화를 통해서 관찰대상의 상태변화를 확인하지만, epoll 방식에서는 다음 구조체 epoll_event를 기반으로 상태변화가 발생한 파일 디스크립터가 별도로 묶인다.

```c
struct epoll_event {
  __uint32_t events;
  epoll_data_t data;
}

typedef union epoll_data {
  void *ptr;
  int fd;
  _uint32_t u32;
  _uint64_t u64;
} epoll_data_t;
```

위의 구조체 epoll_event 기반의 배열을 넉넉한 길이로 선언해서 epoll_wait 함수호출 시 인자로 전달하면, 상태변화가 발생한 파일 디스크립터의 정보가 이 배열에 별도로 묶이기 때문에 select 함수에서 보인, 전체 파일 디스크립터를 대상으로 하는 반복문은 불필요하다. 이렇게 해서 간단히 epoll 방식에서 사용되는 함수와 구조체에 대해서 살펴보았다. 사실 epoll 은 select 방식에 대한 경험이 있으면 어렵지 않게 적용 가능하다.

## epoll_create
