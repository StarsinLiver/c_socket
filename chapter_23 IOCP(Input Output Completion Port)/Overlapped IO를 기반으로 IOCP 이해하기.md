## Overlapped IO를 기반으로 IOCP 이해하기

이번 챕터에서 소개하는 IOCP 서버 모델은 많은 윈도우 프로그래머의 관심사이다. 여러분도 이에 관심이 많다면 그래서 이전 내용을 건너뛰고 이리 달려온 것이라면 챕터 21 로 다시 가라

## 논의가 한참인 epoll 과 IOCP의 성능 비교

select 와 같은 전통적인 IO모델의 한계극복을 목적으로 운영체제 레벨(커널 레벨)에서 성능을 향상시킨 IO 모델이 운영체제 별로 등장하였다. 그 중 대표적인 것이 리눅스의 epoll , BSD의 kqueue 그리고 이번 챕터에서 설명하는 윈도우의 IOCP이다. 이들의 공통적인 특성은 운영체제에 의해서 기능이 지원 및 완성된다는 것이다. 그런데 여기에는 지금도 논쟁이 되는 것이 있다.

"epoll 이 빨라요? IOCP가 빨라요?"

이에 대한 논쟁은 www.yahoo.com 에서 지금도 확인할 수 있으며, 그 열기는 자칫 감정적으로 치닫는 경우도 더러 있음을 알 수 있다. 사실 서버의 응답시간과 동시접속자 수는 매우 중요한 요소이기 때문에 이에 대한 논쟁도 일리는 있다.

"epoll 로 구현한 서버에서는 동시접속자 수가 문제가 되었는데, IOCP로 바꾸니까 해결되더라고!"
"IOCP의 응답시간이 문제가 되었는데, epoll로 바꾸니깐 해결되더라고!"

그리고 하드웨어의 성능이나 할당된 대역폭이 충분한 상황에서 응답시간이나 동시접속자 수에 문제가 발생하면 필자는 다음 두 가지를 먼저 의심한다. 그리고 이 둘을 수정함으로써 대부분의 문제를 해결한다.

```
1. 비효율적인 IO의 구성 또는 비효율적인 CPU의 활용
2. 데이터베이스의 설계내용과 쿼리(Query) 구성
```

때문에 인터넷상에서 흔히 접하는 IOCP가 상대적으로 우월한 이유를 가지고 필자에게 물어오는 친구들에게는 모르겠다고 한다.

왜냐하면 다른 IO모델에 없는 장점이 IOCP에 있긴하지만, 그것이 서버의 성능을 좌우하는 절대적 기준은 아니며 모든 상황에서 그 장점이 부각되는 것도 아니기 때문이다. 오히려 이들의 성능을 좌우하는 것은 눈에 보이는 차이점이 아닌 눈에 보이지 않는 그래서 비교하기 어려운 운영체제의 내부 동작방식에 있지 않나 생각한다. 다만 필자처럼 생각하고 있는 개발자들도 주변에는 많다는 사실을 여러분에게 알리고 싶다.
