## HTTP(Hypertext Transfer Protocol)의 개요 - 웹 서버의 이해

인터넷의 대중화롤 인해서 웹 서버가 무엇인지를 모르는 사람은 거의 없게 되었다. 그럼 필자가 웹 서버를 간단히 정의해 보겠다.

"HTTP 프로토콜을 기반으로 웹 페이지에 해당하는 파일을 클라이언트에게 전송하는 역할의 서버"

위에서 정의한 HTTP란 Hypertext Transfer Protocol의 약자이다. 그리고 Hypertext란 클라이언트의 선택에 따라서 이동이 가능한 조직화된 정보를 의미한다. 예를 들어서 우리가 인터넷 브라우저를 통해서 오렌지미디어의 홈페이지에 접속하면 메인 페이지라 불리는 첫 번째 페이지의 파일이 브라우저로 전송되어 우리에게 보여지게 된다. 그러면 우리는 마우스를 클릭해서 이동하고픈 곳으로 이동할 수 있다.

이렇듯 이동이 가능한 Text를 가리켜 Hypertext라 한다.

그렇다면 HTTP 프로토콜이란 무엇일까? HTTP프로토콜은 Hypertext의 전송을 목적으로 설계된 어플리케이션 레벨의 프로토콜이다. 즉, TCP/IP를 기반으로 구현된 프로토콜이기 때문에 우리도 HTTP를 직접 구현할 수 있다.
그리고 이를 구현하는 것이 결과적으로 웹 서버를 구현하는 것이 된다. 참고로 인터넷 브라우저도 소켓 기반의 클라이언트 프로그램이다. 왜냐하면 임의의 웹 서버에 접속을 시도하기 위해서 브라우저도 내부적으로 소켓을 생성하기 때문이다. 다만 인터넷 브라우저는 서버가 전송하는 HTML문으로 이뤄진 Hypertext를 HTML문법을 근거로 보기 좋게 변환해서 보여주는 특징을 지니고 있을 뿐이다.

정리하면 웹 서버는 HTTP라는 이름의 프로토콜을 깁나으로 Hypertext를 전송하는 서버이다.

## HTTP(Hyper Transfer Protocol)

그럼 보다 구체적으로 HTTP 프로토콜을 살펴보자

### 1. 상태가 존재하지 않는 Stateless 프로토콜

HTTP 프로토콜의 요청 및 응답방식은 인터넷이라는 환경하에서 많은 클라이언트에게 서비스할 수 있도록 다음과 같이 간단히 설계되어있다,

![alt text](/image/39.png)

위 그림을 보면 서버는 클라이언트의 요청에 응답을 하고 나서 연결을 바로 끊음을 알 수 있다. 즉, 서버는 클라이언트의 상태정보를 유지하지 않는다. 앞서 요청했던 클라이언트가 다시 요청을 해 와도 클라이언트가 조금 전에 한 차례 요청을 했던 클라이언트임을 인식하지 못한다. 다만 새로운 요청에 대해서 동일한 형태로 응답만 해 줄 뿐이다. 때문에 HTTP를 가리켜 상태가 존재하지 않는, Stateless 프로토콜이라 한다.

### (추가 정보) cookie 와 session

웹 프로그래밍 기술에는 연결상태가 유지되지 않는 HTTP의 특징을 보완하고자 쿠키와 세션이라는 이름의 기술이 개발되어 사용되고 있다. 인터넷 쇼핑몰에 보면 장바구니 기능이 있지 않은가? 이 장바구니에 담긴 정보는 브라우저를 종료시킨 다음에도 계속 유지되는 경우를 볼 수 있다. 이렇게 상태정보의 유지가 가능한 것은 쿠키와 세션이라는 이름의 기술이 사용되기 때문이다.

### 2. 요청 메시지(Request Message)의 구성

클라이언트가 웹 서버에 보내는 요청 메시지가 어떻게 구성되어야 하는지 살펴보자. 웹 서버는 클라이언트의 요청을 인식하고 그에 맞는 응답을 해줘야 한다. 따라서 클라이언트와 웹 서버 사이의 데이터 요청방식은 다음과 같이 표준화 되어 있다.

![alt text](/image/40.png)

위 그림에서 보이듯이 요청메시지는 요청 라인, 메시지 헤더 , 메시지 몸체 , 이렇게 총 세 부분으로 나뉘며, 이 중에서 '요청라인'에는 요청방식(요청 목적)에 대한 정보가 삽입된다. 대표적인 요청방식으로는 GET 과 POST가 있다. GET은 주로 데이터를 요청하는 경우에 사용되며, POST는 데이터를 전송하는 경우에 사용된다. 그러나 우리는 간단한 구현을 위해서 GET방식의 요청에만 응답하는 웹 서버를 구현할 것이다.

위 문장 start line 에 삽입된 문장 'GET /test.html HTTP/1.1' 은 다음과 같이 해석된다.

"test.html파일을 요청(GET)합니다. 그리고 저는 HTTP프로토콜 버전 1.1 기준으로 통신하기를 원합니다."

또한 'start line'은 반드시 하나의 행(line)으로 구성해서 전송하도록 약속되어 있으니, 전체 HTTP 요청헤더 중 첫번째 행을 추출해서 쉽게 요청 라인에 삽입된 정보를 확인할 수 있다.

요청 라인의 아랫부분에 존재하는 메시지 헤더에는 요청에 사용된(응답 받을) 브라우저 정보, 사용자 인증정보등 HTTP 메시지에 대한 부가적인 정보가 담긴다. 마지막으로 메시지 몸체에는 클라이언트가 웹 서버에게 전송할 데이터가 담기게 되는데, 이를 담기 위해서는 POST 방식으로 요청을 해야 한다. 그런데 우리는 GET 방식의 요청에만 응답하는 웹 서버를 구현하기로 하자.

### 3. 응답 메시지(Response Message)의 구성

이번에는 웹 서버가 클라이언트에게 전달하는 응답 메시지의 구성을 소개하겠다. 이 응답메시지는 상태 라인, 헤더 정보, 메시지 몸체 이렇게 3부분으로 나뉜다. 요청 메시지와의 차이는 요청라인을 대신해서 요청에 대한 상태정보가 담기는 '상태 라인'이 삽입된다는 점이다.

![alt text](/image/41.png)

위 그림에서 보이듯이 제일 첫번째 문자열로 들어가는 '상태 라인' 에는 클라이언트의 요청에 대한 결과 정보가 담긴다. 예를 들어 클라이언트가 index.html 파일을 요청한 경우. index.html 파일이 존재하는지 존재하지 않는지, 혹은 서버에 문제가 발생해서 응답할 수 없는 상황인지에 대한 정보가 담긴다. 참고로 위 그림에서 제시된 'HTTP/1.1 200 OK'는 성공적인 것이다.

이어서 등장하는 메시지의 헤더에는 전송되는 데이터의 타입 및 길이정보등이 담긴다. 위 그림의 메시지 헤더에 담긴 정보는 다음과 같다.

"서버의 이름은 apache 이고, 전송하는 데이터의 타입은 text/html 이다. 그리고 데이터의 길이는 35 바이트를 넘지 않는다."

마지막으로 공백 라인이 하나 삽입된 다음에 멤시지 몸체를 통해서 클라이언트가 요청한 파일의 데이터가 전송된다. 지금까지 웹 서버의 구현에 필요한 HTTP 프로토콜을 일부 소개하였다. 우리는 간단한 웹 서버를 만들것이므로 이정도만 알아도 된다.
